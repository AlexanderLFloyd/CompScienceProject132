import threading, time, queue, sqlite3, abc

# Database file: contains database function and task objects

class QueuedTask(metaclass=abc.ABCMeta):
    def __init__(self,data):
        # input data to be in form of tuple/list [long/int timestamp, int s1, ... int sn]
        #   where sn is the data collected from sensor n at the listed time
        # output task (data) to be in form of tuple/list [long/int a, long/int b]
        pass
    def execute(self,db,rq):
        pass
        

class InputTask(QueuedTask): # Execute an insertion into the database of sensor data.
    def __init__(self,data):
        self.data = data
    def execute(self,db,rq):
        if(self.data == None):
            raise Exception("Empty QueuedTask: InputTask")
        else:
            # Insert task.data into the database
            db.execute("INSERT INTO sensors VALUES (?,?,?)".format(self.data))

class OutputTask(QueuedTask): # Executes a selection query from the database and send the data to the return queue.
    def __init__(self,data):
        self.data = data
    def execute(self,db,rq):
        if(self.data == None):
            raise Exception("Empty QueuedTask: OutputTask")
        else:
            # Get the data from timestamp task.data[0] to timestamp task.data[1]
            # result_set query = SELECT * FROM sensorData WHERE timestamp >= task.data[0] AND timestamp <= task.data[1]
            result_set = db.execute("SELECT * FROM sensorData WHERE timestamp >= ? AND timestampe <= ?", self.data)
            rq.put(result_set)

schema = """CREATE TABLE sensors (timestamp INTEGER, soil_1 INTEGER, soil_2 INTEGER)"""

# Database layer (The database is made thread-safe by using this separate thread
#   to insert or get data from the database. Queues are used to queue insert and
#   query tasks to the database layer.)
# Table: (to be expanded)
#  |------------------------------------------------------------|
#  | INTEGER timestamp | INTEGER soil_bottom | INTEGER soil_top |
#  |-------------------|---------------------|------------------|
#  | LONG integer      |       integer       |      integer     |
#
def databaseConnector(dbQueue,returnQueue,dbEnabled):
    # Connect to database
    dbCon = sqlite3.connect("sensordata.db")
    db = dbCon.cursor()
    # GLOBAL DBQueue      # Tasks from datacollector/user
    # GLOBAL returnQueue  # Used to return data to the user
    # BLOCK_TIME          # The maximum amount of time (seconds) the queue will wait for a new task (if empty)

    while(True): # Database thread is always running
        while(dbEnabled): # Database will only insert/query when enabled
            if(dbQueue.qsize() > 0):
                # Will wait until data is available in the queue
                # The object from the Queue will be eiter an OutputTask or InputTask object, both inherriting from QueuedTask.
                task = dbQueue.get(block=True,timeout=None)
                task.execute(db,returnQueue)
